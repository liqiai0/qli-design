# 设计模式
## 什么是设计模式
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式：面向对象的设计模式，向上，如何将我们世界抽象为程序代码，向下，如何把握机器底层从微观理解对象构造
向下：深入理解三大面向对象思维机制（底层思维）

*	封装，隐藏内部实现
*	继承，复用现有代码
*	多态，改写对象行为（继承、重写、向上）

向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用面向对象思维表达现实世界(上层思维)

##重新认识面向对象

1.	从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响降低到最小
2.	微观层面上更强调类的责任，各司其职，新增类并不改变原类的实现
3.	对象是什么？
	1).	从语言的实现来看，对象封装了代码和数据。
	2).	从规格层面上讲，对象是一系列可被使用的公共接口。
	3).	从概念层面讲，对象是某种拥有责任的抽象

## 设计原则（重要）
### <font color=red>1.依赖倒置原则（DIR）</font>
*	高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定)。
*	抽象不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)（变化依赖于稳定，稳定依赖于稳定）

### <font color=red>2.开闭原则（OCP）</font>
*	对扩展开放，对更改封闭。（类模块是可开放的，是不可修改的）
*	类模块应该是可扩展的，但是不可修改。

### <font color=red>3.单一职责原则（SRP）</font>
*	一个类应该仅有一个引起它变化的原因。(类责任)
*	变化的方向隐含类的责任

### <font color=red>4.替换原则（LSP）</font>
*	子类必须能够替换他们的基类
*	继承表达类型抽象

### <font color=red>5.接口隔离原则（ISP）</font>
*	不应该强迫客户程序依赖他们不用的方法
*	接口应该小而完备。

### <font color=red>6.优先使用对象组合，而不是类继承</font>
*	类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。<类属关系>
*	继承在某种程度上破坏了封装性，子类父类耦合度高。
*	而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

### <font color=red>7.封装变化点 </font>
*	使用封装来创建对象之间的分界层，让设计者可以在分解一侧进行修改，而不会对另一侧产生不良影响，从而实现层次间的耦合。(从传统的面向对象思维的上说，封装代码和数据，实际上是封装变化点，一侧变化一侧稳定)

### <font color=red>8.针对接口编程，而不是针对实现编程</font>
*	不将变了类型声明为某个特定的具体类，而是声明为某个接口
*	客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
*	减少系统中各部分的依赖关系，从而实现“高内聚，低耦合”的类型关系

## 创建型模式
* Singleton模式解决的是实体对象个数的问题。除了Singleton之外，其他创建型模式解决的都是new所带来的耦合关系。
* Factory Method, Abstract Factory, Builder都需要一个额外的工厂类来负责实例化“易变对象”，而Prototype则是通过原型（一个特殊的工厂类）来克隆“易变对象”。
* 如果遇到“易变类”，起初的设计通常从FactoryMethod开始，当遇到更多的复杂变化时，再考虑重构为其他三种工厂模式（ Abstract Factory,Builder ， Prototype ）。

## 结构型模式
* Adapter模式注重转换接口，将不吻合的接口适配对接
* Bridge模式注重分离接口与其实现，支持多维度变化
* Composite模式注重统一接口，将“一对多”的关系转化为“一对一”的关系
* Decorator模式注重稳定接口，在此前提下为对象扩展功能
* Facade模式注重简化接口，简化组件系统与外部客户程序的依赖关系
* Flyweight 模式注重保留接口，在内部使用共享技术对对象存储进行优化
* Proxy 模式注重假借接口，增加间接层来实现灵活控制

## 行为型模式（1）
* Template Method模式封装算法结构，支持算法子步骤变化
* Strategy模式注重封装算法，支持算法的变化
* State模式注重封装与状态相关的行为，支持状态的变化
* Memento模式注重封装对象状态变化，支持状态保存/恢复
* Mediator模式注重封装对象间的交互，支持对象交互的变化

## 行为型模式（2）
* Chain Of Responsibility模式注重封装对象责任，支持责任的变化
* Command模式注重将请求封装为对象，支持请求的变化
* Iterator 模式注重封装集合对象内部结构，支持集合的变化
* Interpreter模式注重封装特定领域变化，支持领域问题的频繁变化
* Observer模式注重封装对象通知，支持通信对象的变化
* Visitor模式注重封装对象操作变化，支持在运行时为类层次结构动态添加新的操作。

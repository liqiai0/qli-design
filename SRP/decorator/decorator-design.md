##桥接模式
###<font color= red >设计场合：</font>
&nbsp;&nbsp;&nbsp;&nbsp;我们通常可以使用继承来实现功能的拓展，如果这些需要拓展的功能的种类繁多，那么势必生成很多子类，增加系统的复杂性，同时，使用继承实现功能的拓展，在编译时候就确定了，这是静态的。而使用装饰模式，在运行期间决定增加何种功能。动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活。装饰者与被装饰者拥有共同的超类，继承的目的是继承类型，而不是行为。装饰者模式的设计原则为：对扩展开放、对修改关闭，这句话体现在我如果想扩展被装饰者类的行为，无须修改装饰者抽象类，只需继承装饰者抽象类，实现额外的一些装饰或者叫行为即可对被装饰者进行包装
解决问题
动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。不改变接口的前提下，增强所考虑的类的性能。

何时使用：
  1.	需要扩展一个类的功能，或给一个类增加附加责任。
  2.	需要动态的给一个对象增加功能，这些功能可以再动态地撤销。
  3.	需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使继承变得    不现实。
###<font color= green >例子：</font>
  咖啡是一种饮料，咖啡的本质是咖啡豆+水磨出来的。咖啡店现在要卖各种口味的咖啡，如果不使用装饰模式，那么在销售系统中，各种不一样的咖啡都要产生一个类，如果有4中咖啡豆，5种口味，那么将要产生至少20个类（不包括混合口味），非常麻烦。使用了装饰模式，只需要11个类即可生产任意口味咖啡（包括混合口味）。